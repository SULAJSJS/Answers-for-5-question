// 1 Что такое Promise и зачем он нужен?


/* 
Вообще Promise это оъбект который показывает окончательное завершение или сбой асинхронной опирации.


Для чего нужен Promise
Использование промисов дает гарантию, что данные, полученные из API, не будут обрабатываться или форматироваться до тех пор, пока вызов API не будет успешно выполнен.

const promise = new Promise(function(resolve, reject) {
        setTimeout(() => {
        console.log('prosecing')

        const Data = {
            server: 'efoecv',
            port: 'ygfie',
            status: '200'
        }

        resolve()
    }, 3000)
})

promise.then(() => {
    console.log('prosess is done')
})

*/


// 2. acync/await



/*
Конструкция async/await можно считать замечательным улучшением в сфере асинхронного программирования на JavaScript. Она позволяет писать код, который выглядит как синхронным, но используется для решения асинхронных задач и не блокирует главный поток. 
В нем код будет выполнятся так, что он не переидёт к оброботке сделующего кода, если он будет эдатьь пока код по порядку не выполнися!


const URL = 'https://jsonplaceholder.typicode.com/posts'

async function async/await() {
    await delay(3000)
    const response = await fetch(URL)
    const data - await response.json()
    console.log(data)
}


async/await(

*/


// 4. Замыкание JS


/*
Другими словами, замыкание даёт вам доступ к Scope внешней функции из внутренней функции. 
В JavaScript замыкания создаются каждый раз при создании функции, во время её создания.


function YourName() {
  const message = 'Привет, как тебя зовут?:';
  return function(name) {
    return message + name + '.';
  }
}

const result = YourName();
console.log(result('Круто!'));
*/

// 3. Контекст JS

/*

Контекст выполнения функции — Это одно из фундаментальных понятий в JavaScript.
Контекстом еще часто называют значение переменной this внутри функции. 


Ключевое слово this представляет указатель на текущий объект данного класса. 
Соответственно через this мы можем обращаться внутри класса к любым его членам.

    const test = {
    prop: 42,
    func: function() {
        return this.prop;
    },
    };

    console.log(test.func());

*/


// 5. Зачем нужны стрелочные функции, разница в функциях.


/*

Зачем нужны стрелочные функции, разница в функциях
У стрелочных функций есть два основных преимущества перед традиционными функциями. 
Первое — это очень удобный и компактный синтаксис. Второе заключается в том, что подход к работе со значением this в стрелочных функциях выглядит интуитивно понятнее, чем в обычных функциях.



В отличие от других функций, стрелочные функции не имеют собственного контекста выполнения. 
На практике это означает, что они наследуют сущности this и arguments от родительской функции.



Простая функция:


function Car(color) {

this.color = color;

}

const redCar = new Car('red');

redCar instanceof Car;


Стрелочная функция:

const Car = (color) => {

this.color = color;

};

const redCar = new Car('red');
*/